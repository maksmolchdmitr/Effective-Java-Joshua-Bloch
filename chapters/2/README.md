1. Применение статических фабричных методов вместо конструкторов
    1. Куча плюсов статических фабричных методов
        1. Имеют имена в отличие от конструкторов
        2. Не обязаны создавать новые объекты при каждом вызове
            1. Улучшение производительности
            2. Паттерн Flyweight
            3. Immutable классы
            4. Instance-controlled
        3. Могут возвращать объект любого подтипа
            1. Возможность сокрытия реализации возвращаемого объекта
            2. public static методы в интерфейсах с Java
               8 ([см. #2](https://github.com/maksmolchdmitr/Effective-Java-Joshua-Bloch/tree/main/useful/links))
            3. private static методы в интерфейсах с Java
               9 ([см. #2](https://github.com/maksmolchdmitr/Effective-Java-Joshua-Bloch/tree/main/useful/links))
        4. Класс возвращенного объекта может варьироваться от входных параметров
            1. EnumSet и его реализации RegularEnumSet и
               JumboEnumSet ([см. #3](https://github.com/maksmolchdmitr/Effective-Java-Joshua-Bloch/tree/main/useful/links))
        5. Класс возвращаемого объекта не обязан существовать
            1. Паттерн Bridge
    2. Два минуса
        1. Не могут порождать подклассы
            1. Пожалуй это может быть и благом
        2. Трудно отличить от других статических методов
            1. Распространенные имена для статических фабричных методов
2. Большое кол-во параметров в конструкторе? - паттерн Builder
    1. Шаблон телескопического конструктора
        1. Трудно писать код клиента и трудно читать
    2. Шаблон JavaBeans
        1. Может оказаться в несогласованном состоянии
        2. Нет возможности сделать класс Immutable
    3. Паттерн Builder [см. #4](https://github.com/maksmolchdmitr/Effective-Java-Joshua-Bloch/tree/main/useful/links)
        1. Имитирует именованные необязательные параметры
        2. Хорошо подходит для иерархии классов
3. Получение Singleton с помощью закрытого конструктора или типа перечисления
    1. С помощью private конструктора и статического фабричного метода
        1. Является Supplier<?> и может создавать отдельный экземпляр на каждый вызов
        2. Нет защиты от рефлексии
        3. Сложным механизм встраивания сериализации
    2. С помощью enum
        1. "Бесплатная" сериализация
        2. Защита от рефлексии
        3. Более компактный
4. Обеспечение неинстанцируемости с помощью закрытого конструктора
    1. Использовать не abstract, а private конструктор для класса который должен быть неинстанцируемым
5. Dependency injection
    1. Не нужно использовать singleton для класса зависящего от других ресурсов
    2. Dependency injection через конструктор и фреймворки Spring и др.
6. Избегайте создания лишних объектов
    1. Использование статических фабричных методов
    2. Проблема функции String.matches с созданием ненужных одинаковых объектов класса Pattern
    3. Про паттерн
       Адаптер [см. #5](https://github.com/maksmolchdmitr/Effective-Java-Joshua-Bloch/tree/main/useful/links)
    4. Про keySet в Map
    5. Отдавайте предпочтение примитивам
7. Избегайте устаревших ссылок на объекты
    1. Пример класса Stack с утечкой памяти
    2. Обнуление ссылки на ненужный объект, но должно быть скорее исключением, чем нормой
    3. Использование WeakHashMap для
       кеширования [см. #6](https://github.com/maksmolchdmitr/Effective-Java-Joshua-Bloch/tree/main/useful/links)
8. Избегайте финализаторов и очистителей
    1. Финализаторы непредсказуемы, часто опасны и в общем случае не нужны.
    2. Очистители менее опасны, чем финализаторы, но столь же не предсказуемые, медленные и, в общем случае, ненужные.
    3. Реализуйте интерфейс AutoClosable
9. Предпочитайте try-with-resources использованию try-finally